# 分布式锁实现

## 1. 分布式锁概述

在如意订单系统中，分布式锁是解决并发问题的关键技术。系统基于Redisson实现了高性能、高可用的分布式锁机制，用于解决订单支付回调、库存扣减、优惠券使用等场景下的并发问题。

### 1.1 使用场景分析

#### 1.1.1 订单支付回调场景
```java
// 问题：支付系统可能重复回调，或与订单取消并发执行
// 解决：使用多重分布式锁
private void payCallbackMultiLock(List<String> redisKeyList, String orderId) {
    // 支付锁 - 防止重复支付回调
    String orderPayKey = RedisLockKeyConstants.ORDER_PAY_KEY + orderId;
    // 取消锁 - 防止支付和取消并发
    String cancelOrderKey = RedisLockKeyConstants.CANCEL_KEY + orderId;
    
    redisKeyList.add(orderPayKey);
    redisKeyList.add(cancelOrderKey);
    
    boolean lock = redisLock.multiLock(redisKeyList);
    if (!lock) {
        throw new OrderBizException(OrderErrorCodeEnum.ORDER_PAY_CALLBACK_ERROR);
    }
}
```

#### 1.1.2 库存扣减场景
```java
// 问题：高并发下可能出现库存超卖
// 解决：基于Redis的原子操作
public boolean deductStock(String skuCode, Integer quantity) {
    String lockKey = RedisLockKeyConstants.INVENTORY_LOCK_KEY + skuCode;
    boolean lock = redisLock.lock(lockKey, 10); // 10秒超时
    
    if (!lock) {
        throw new OrderBizException(OrderErrorCodeEnum.INVENTORY_LOCK_FAILED);
    }
    
    try {
        // 检查并扣减库存
        return doDeductStock(skuCode, quantity);
    } finally {
        redisLock.unlock(lockKey);
    }
}
```

#### 1.1.3 优惠券使用场景
```java
// 问题：同一优惠券可能被多个订单同时使用
// 解决：基于用户和优惠券的组合锁
public boolean lockCoupon(String userId, String couponId) {
    String lockKey = RedisLockKeyConstants.COUPON_LOCK_KEY + userId + ":" + couponId;
    boolean lock = redisLock.lock(lockKey, 30); // 30秒超时
    
    if (!lock) {
        throw new OrderBizException(OrderErrorCodeEnum.COUPON_LOCK_FAILED);
    }
    
    try {
        return doLockCoupon(userId, couponId);
    } finally {
        redisLock.unlock(lockKey);
    }
}
```

### 1.2 技术选型对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| Redis SET NX | 简单易用 | 不支持重入，容易死锁 | 简单场景 |
| Redisson | 功能丰富，支持重入 | 依赖Redis | 复杂分布式场景 |
| Zookeeper | 强一致性 | 性能较差，复杂度高 | 强一致性要求 |
| 数据库锁 | 事务支持好 | 性能差，不适合高并发 | 低并发场景 |

## 2. Redisson分布式锁实现

### 2.1 Redisson配置

#### 2.1.1 Redis集群配置
```yaml
spring:
  redis:
    cluster:
      nodes:
        - 192.168.1.101:6379
        - 192.168.1.102:6379
        - 192.168.1.103:6379
        - 192.168.1.104:6379
        - 192.168.1.105:6379
        - 192.168.1.106:6379
      max-redirects: 3
    timeout: 3000ms
    password: redis123
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5
        max-wait: 3000ms
```

#### 2.1.2 Redisson客户端配置
```java
@Configuration
public class RedissonConfig {
    
    @Value("${spring.redis.cluster.nodes}")
    private String clusterNodes;
    
    @Value("${spring.redis.password}")
    private String password;
    
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        
        // 集群配置
        String[] nodes = clusterNodes.split(",");
        for (int i = 0; i < nodes.length; i++) {
            nodes[i] = "redis://" + nodes[i].trim();
        }
        
        ClusterServersConfig clusterConfig = config.useClusterServers()
                .addNodeAddress(nodes)
                .setPassword(password)
                .setMasterConnectionPoolSize(20)    // 主节点连接池大小
                .setSlaveConnectionPoolSize(20)     // 从节点连接池大小
                .setMasterConnectionMinimumIdleSize(5)  // 主节点最小空闲连接
                .setSlaveConnectionMinimumIdleSize(5)   // 从节点最小空闲连接
                .setIdleConnectionTimeout(10000)    // 空闲连接超时
                .setConnectTimeout(3000)            // 连接超时
                .setTimeout(3000)                   // 响应超时
                .setRetryAttempts(3)                // 重试次数
                .setRetryInterval(1500);            // 重试间隔
        
        // 编码配置
        config.setCodec(new JsonJacksonCodec());
        
        return Redisson.create(config);
    }
    
    @Bean
    public RedisLock redisLock(RedissonClient redissonClient) {
        return new RedisLock(redissonClient);
    }
}
```

### 2.2 分布式锁核心实现

#### 2.2.1 RedisLock核心类
```java
public class RedisLock {
    
    private final RedissonClient redissonClient;
    private final Map<String, RLock> lockMap = new ConcurrentHashMap<>();
    
    public RedisLock(RedissonClient redissonClient) {
        this.redissonClient = redissonClient;
    }
    
    /**
     * 获取锁（自动续期）
     * @param key 锁的key
     * @return 是否获取成功
     */
    public boolean lock(String key) {
        RLock rLock = redissonClient.getLock(key);
        try {
            boolean locked = rLock.tryLock();
            if (locked) {
                lockMap.put(key, rLock);
                log.debug("获取分布式锁成功, key: {}, threadId: {}", key, Thread.currentThread().getId());
            } else {
                log.warn("获取分布式锁失败, key: {}, threadId: {}", key, Thread.currentThread().getId());
            }
            return locked;
        } catch (Exception e) {
            log.error("获取分布式锁异常, key: {}", key, e);
            return false;
        }
    }
    
    /**
     * 获取锁（指定超时时间）
     * @param key 锁的key
     * @param seconds 超时时间（秒）
     * @return 是否获取成功
     */
    public boolean lock(String key, int seconds) {
        RLock rLock = redissonClient.getLock(key);
        try {
            boolean locked = rLock.tryLock(0, seconds, TimeUnit.SECONDS);
            if (locked) {
                lockMap.put(key, rLock);
                log.debug("获取分布式锁成功, key: {}, timeout: {}s, threadId: {}", 
                         key, seconds, Thread.currentThread().getId());
            } else {
                log.warn("获取分布式锁失败, key: {}, timeout: {}s, threadId: {}", 
                        key, seconds, Thread.currentThread().getId());
            }
            return locked;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("获取分布式锁被中断, key: {}", key, e);
            return false;
        } catch (Exception e) {
            log.error("获取分布式锁异常, key: {}", key, e);
            return false;
        }
    }
    
    /**
     * 尝试获取锁（非阻塞）
     * @param key 锁的key
     * @param waitTime 等待时间
     * @param leaseTime 锁持有时间
     * @param timeUnit 时间单位
     * @return 是否获取成功
     */
    public boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit timeUnit) {
        RLock rLock = redissonClient.getLock(key);
        try {
            boolean locked = rLock.tryLock(waitTime, leaseTime, timeUnit);
            if (locked) {
                lockMap.put(key, rLock);
                log.debug("尝试获取分布式锁成功, key: {}, waitTime: {}, leaseTime: {}, threadId: {}", 
                         key, waitTime, leaseTime, Thread.currentThread().getId());
            } else {
                log.warn("尝试获取分布式锁失败, key: {}, waitTime: {}, leaseTime: {}, threadId: {}", 
                        key, waitTime, leaseTime, Thread.currentThread().getId());
            }
            return locked;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("尝试获取分布式锁被中断, key: {}", key, e);
            return false;
        } catch (Exception e) {
            log.error("尝试获取分布式锁异常, key: {}", key, e);
            return false;
        }
    }
    
    /**
     * 释放锁
     * @param key 锁的key
     */
    public void unlock(String key) {
        RLock rLock = lockMap.remove(key);
        if (rLock != null && rLock.isHeldByCurrentThread()) {
            try {
                rLock.unlock();
                log.debug("释放分布式锁成功, key: {}, threadId: {}", key, Thread.currentThread().getId());
            } catch (Exception e) {
                log.error("释放分布式锁异常, key: {}", key, e);
            }
        } else {
            log.warn("释放分布式锁失败，锁不存在或不由当前线程持有, key: {}, threadId: {}", 
                    key, Thread.currentThread().getId());
        }
    }
    
    /**
     * 多重锁（联锁）
     * @param redisKeyList 锁的key列表
     * @return 是否全部获取成功
     */
    public boolean multiLock(List<String> redisKeyList) {
        if (redisKeyList == null || redisKeyList.isEmpty()) {
            return true;
        }
        
        try {
            RLock multiLock = getMultiLock(redisKeyList);
            boolean locked = multiLock.tryLock();
            
            if (locked) {
                // 将多重锁存储，使用组合key
                String multiKey = String.join(":", redisKeyList);
                lockMap.put(multiKey, multiLock);
                log.debug("获取多重锁成功, keys: {}, threadId: {}", redisKeyList, Thread.currentThread().getId());
            } else {
                log.warn("获取多重锁失败, keys: {}, threadId: {}", redisKeyList, Thread.currentThread().getId());
            }
            
            return locked;
        } catch (Exception e) {
            log.error("获取多重锁异常, keys: {}", redisKeyList, e);
            return false;
        }
    }
    
    /**
     * 释放多重锁
     * @param redisKeyList 锁的key列表
     */
    public void unMultiLock(List<String> redisKeyList) {
        if (redisKeyList == null || redisKeyList.isEmpty()) {
            return;
        }
        
        String multiKey = String.join(":", redisKeyList);
        RLock multiLock = lockMap.remove(multiKey);
        
        if (multiLock != null && multiLock.isLocked()) {
            try {
                multiLock.unlock();
                log.debug("释放多重锁成功, keys: {}, threadId: {}", redisKeyList, Thread.currentThread().getId());
            } catch (Exception e) {
                log.error("释放多重锁异常, keys: {}", redisKeyList, e);
            }
        } else {
            log.warn("释放多重锁失败，锁不存在或已释放, keys: {}, threadId: {}", 
                    redisKeyList, Thread.currentThread().getId());
        }
    }
    
    /**
     * 创建多重锁
     */
    private RLock getMultiLock(List<String> redisKeyList) {
        RLock[] locks = new RLock[redisKeyList.size()];
        for (int i = 0; i < redisKeyList.size(); i++) {
            RLock lock = redissonClient.getLock(redisKeyList.get(i));
            locks[i] = lock;
        }
        return redissonClient.getMultiLock(locks);
    }
}
```

### 2.3 锁常量定义

#### 2.3.1 锁Key常量
```java
public class RedisLockKeyConstants {
    
    // 订单相关锁
    public static final String ORDER_PAY_KEY = "lock:order:pay:";
    public static final String ORDER_CANCEL_KEY = "lock:order:cancel:";
    public static final String ORDER_FULFILL_KEY = "lock:order:fulfill:";
    public static final String ORDER_STATUS_UPDATE_KEY = "lock:order:status:";
    
    // 库存相关锁
    public static final String INVENTORY_LOCK_KEY = "lock:inventory:";
    public static final String INVENTORY_DEDUCT_KEY = "lock:inventory:deduct:";
    public static final String INVENTORY_RELEASE_KEY = "lock:inventory:release:";
    
    // 优惠券相关锁
    public static final String COUPON_LOCK_KEY = "lock:coupon:";
    public static final String COUPON_USE_KEY = "lock:coupon:use:";
    public static final String COUPON_RELEASE_KEY = "lock:coupon:release:";
    
    // 用户相关锁
    public static final String USER_OPERATION_KEY = "lock:user:operation:";
    
    // 系统级别锁
    public static final String SYSTEM_TASK_KEY = "lock:system:task:";
    public static final String DATA_SYNC_KEY = "lock:data:sync:";
    
    // 取消订单锁的别名（为了兼容性）
    public static final String CANCEL_KEY = ORDER_CANCEL_KEY;
}
```

## 3. 具体应用场景实现

### 3.1 订单支付回调锁

#### 3.1.1 支付回调多重锁
```java
@Service
public class PaymentCallbackService {
    
    @Autowired
    private RedisLock redisLock;
    
    public void handlePayCallback(PayCallbackRequest request) {
        String orderId = request.getOrderId();
        
        // 构建多重锁key列表
        List<String> lockKeys = buildPayCallbackLockKeys(orderId);
        
        // 获取多重锁
        boolean locked = redisLock.multiLock(lockKeys);
        if (!locked) {
            log.error("获取支付回调锁失败, orderId: {}", orderId);
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_PAY_CALLBACK_LOCK_FAILED);
        }
        
        try {
            // 执行支付回调业务逻辑
            processPayCallback(request);
            
        } finally {
            // 释放多重锁
            redisLock.unMultiLock(lockKeys);
        }
    }
    
    private List<String> buildPayCallbackLockKeys(String orderId) {
        List<String> lockKeys = new ArrayList<>();
        
        // 支付锁 - 防止重复支付回调
        lockKeys.add(RedisLockKeyConstants.ORDER_PAY_KEY + orderId);
        
        // 取消锁 - 防止支付和取消并发
        lockKeys.add(RedisLockKeyConstants.ORDER_CANCEL_KEY + orderId);
        
        return lockKeys;
    }
    
    private void processPayCallback(PayCallbackRequest request) {
        String orderId = request.getOrderId();
        
        // 1. 幂等性检查
        if (isAlreadyPaid(orderId)) {
            log.info("订单已支付，跳过处理, orderId: {}", orderId);
            return;
        }
        
        // 2. 更新订单支付状态
        updateOrderPayStatus(request);
        
        // 3. 发送履约消息
        sendFulfillMessage(orderId);
        
        log.info("支付回调处理完成, orderId: {}", orderId);
    }
}
```

#### 3.1.2 支付回调锁的超时处理
```java
@Component
public class PayCallbackLockManager {
    
    @Autowired
    private RedisLock redisLock;
    
    /**
     * 带超时的支付回调锁
     */
    public boolean tryLockPayCallback(String orderId, long waitTimeMs, long leaseTimeMs) {
        List<String> lockKeys = Arrays.asList(
            RedisLockKeyConstants.ORDER_PAY_KEY + orderId,
            RedisLockKeyConstants.ORDER_CANCEL_KEY + orderId
        );
        
        // 尝试获取锁，设置等待时间和持有时间
        for (String lockKey : lockKeys) {
            boolean locked = redisLock.tryLock(lockKey, waitTimeMs, leaseTimeMs, TimeUnit.MILLISECONDS);
            if (!locked) {
                // 释放已获取的锁
                unlockPayCallback(orderId, lockKeys.indexOf(lockKey));
                return false;
            }
        }
        
        return true;
    }
    
    private void unlockPayCallback(String orderId, int unlockIndex) {
        List<String> lockKeys = Arrays.asList(
            RedisLockKeyConstants.ORDER_PAY_KEY + orderId,
            RedisLockKeyConstants.ORDER_CANCEL_KEY + orderId
        );
        
        // 只释放已经获取的锁
        for (int i = 0; i < unlockIndex; i++) {
            redisLock.unlock(lockKeys.get(i));
        }
    }
}
```

### 3.2 库存扣减锁

#### 3.2.1 基于SKU的库存锁
```java
@Service
public class InventoryLockService {
    
    @Autowired
    private RedisLock redisLock;
    
    @Autowired
    private InventoryDAO inventoryDAO;
    
    /**
     * 扣减库存（带锁保护）
     */
    public boolean deductStock(String skuCode, Integer quantity, String orderId) {
        String lockKey = RedisLockKeyConstants.INVENTORY_DEDUCT_KEY + skuCode;
        
        // 获取库存锁，超时时间10秒
        boolean locked = redisLock.lock(lockKey, 10);
        if (!locked) {
            log.error("获取库存锁失败, skuCode: {}, orderId: {}", skuCode, orderId);
            throw new OrderBizException(OrderErrorCodeEnum.INVENTORY_LOCK_FAILED);
        }
        
        try {
            // 检查库存是否充足
            Integer availableStock = getAvailableStock(skuCode);
            if (availableStock < quantity) {
                log.warn("库存不足, skuCode: {}, 需要: {}, 可用: {}", skuCode, quantity, availableStock);
                return false;
            }
            
            // 执行库存扣减
            boolean deducted = doDeductStock(skuCode, quantity, orderId);
            if (deducted) {
                log.info("库存扣减成功, skuCode: {}, quantity: {}, orderId: {}", skuCode, quantity, orderId);
                
                // 记录库存变更日志
                recordInventoryChange(skuCode, quantity, orderId, InventoryChangeTypeEnum.DEDUCT);
            }
            
            return deducted;
            
        } finally {
            redisLock.unlock(lockKey);
        }
    }
    
    /**
     * 批量扣减库存
     */
    public boolean batchDeductStock(List<InventoryDeductRequest> requests, String orderId) {
        // 按SKU排序，避免死锁
        requests.sort(Comparator.comparing(InventoryDeductRequest::getSkuCode));
        
        List<String> lockKeys = new ArrayList<>();
        for (InventoryDeductRequest request : requests) {
            lockKeys.add(RedisLockKeyConstants.INVENTORY_DEDUCT_KEY + request.getSkuCode());
        }
        
        // 获取多重锁
        boolean locked = redisLock.multiLock(lockKeys);
        if (!locked) {
            log.error("获取批量库存锁失败, orderId: {}", orderId);
            throw new OrderBizException(OrderErrorCodeEnum.INVENTORY_BATCH_LOCK_FAILED);
        }
        
        try {
            // 检查所有库存是否充足
            for (InventoryDeductRequest request : requests) {
                Integer availableStock = getAvailableStock(request.getSkuCode());
                if (availableStock < request.getQuantity()) {
                    log.warn("批量库存检查失败, skuCode: {}, 需要: {}, 可用: {}", 
                            request.getSkuCode(), request.getQuantity(), availableStock);
                    return false;
                }
            }
            
            // 批量执行库存扣减
            boolean allSuccess = true;
            for (InventoryDeductRequest request : requests) {
                boolean deducted = doDeductStock(request.getSkuCode(), request.getQuantity(), orderId);
                if (!deducted) {
                    allSuccess = false;
                    break;
                }
            }
            
            if (allSuccess) {
                log.info("批量库存扣减成功, orderId: {}, count: {}", orderId, requests.size());
            } else {
                log.error("批量库存扣减失败, orderId: {}", orderId);
                // 这里可以考虑回滚已扣减的库存
            }
            
            return allSuccess;
            
        } finally {
            redisLock.unMultiLock(lockKeys);
        }
    }
    
    private Integer getAvailableStock(String skuCode) {
        InventoryDO inventory = inventoryDAO.getBySkuCode(skuCode);
        return inventory != null ? inventory.getAvailableStock() : 0;
    }
    
    private boolean doDeductStock(String skuCode, Integer quantity, String orderId) {
        int updatedRows = inventoryDAO.deductStock(skuCode, quantity);
        return updatedRows > 0;
    }
    
    private void recordInventoryChange(String skuCode, Integer quantity, String orderId, InventoryChangeTypeEnum changeType) {
        InventoryChangeLogDO changeLog = new InventoryChangeLogDO();
        changeLog.setSkuCode(skuCode);
        changeLog.setQuantity(quantity);
        changeLog.setOrderId(orderId);
        changeLog.setChangeType(changeType.getCode());
        changeLog.setChangeTime(new Date());
        inventoryChangeLogDAO.save(changeLog);
    }
}
```

#### 3.2.2 Redis原子操作优化
```java
@Service
public class RedisInventoryService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    // Lua脚本保证原子性
    private static final String DEDUCT_STOCK_SCRIPT = 
        "local stock = redis.call('get', KEYS[1]) " +
        "if stock and tonumber(stock) >= tonumber(ARGV[1]) then " +
        "  redis.call('decrby', KEYS[1], ARGV[1]) " +
        "  return 1 " +
        "else " +
        "  return 0 " +
        "end";
    
    private static final String BATCH_DEDUCT_STOCK_SCRIPT = 
        "local success = 1 " +
        "for i = 1, #KEYS do " +
        "  local stock = redis.call('get', KEYS[i]) " +
        "  if not stock or tonumber(stock) < tonumber(ARGV[i]) then " +
        "    success = 0 " +
        "    break " +
        "  end " +
        "end " +
        "if success == 1 then " +
        "  for i = 1, #KEYS do " +
        "    redis.call('decrby', KEYS[i], ARGV[i]) " +
        "  end " +
        "end " +
        "return success";
    
    /**
     * Redis原子扣减库存
     */
    public boolean deductStockAtomic(String skuCode, Integer quantity) {
        String stockKey = "inventory:stock:" + skuCode;
        
        Long result = (Long) redisTemplate.execute(
            new DefaultRedisScript<>(DEDUCT_STOCK_SCRIPT, Long.class),
            Collections.singletonList(stockKey),
            quantity.toString()
        );
        
        boolean success = result != null && result == 1;
        
        if (success) {
            log.info("Redis原子扣减库存成功, skuCode: {}, quantity: {}", skuCode, quantity);
        } else {
            log.warn("Redis原子扣减库存失败, skuCode: {}, quantity: {}", skuCode, quantity);
        }
        
        return success;
    }
    
    /**
     * Redis批量原子扣减库存
     */
    public boolean batchDeductStockAtomic(List<String> skuCodes, List<Integer> quantities) {
        if (skuCodes.size() != quantities.size()) {
            throw new IllegalArgumentException("skuCodes和quantities长度不匹配");
        }
        
        List<String> stockKeys = skuCodes.stream()
            .map(skuCode -> "inventory:stock:" + skuCode)
            .collect(Collectors.toList());
        
        List<String> quantityStrs = quantities.stream()
            .map(String::valueOf)
            .collect(Collectors.toList());
        
        Long result = (Long) redisTemplate.execute(
            new DefaultRedisScript<>(BATCH_DEDUCT_STOCK_SCRIPT, Long.class),
            stockKeys,
            quantityStrs.toArray(new String[0])
        );
        
        boolean success = result != null && result == 1;
        
        if (success) {
            log.info("Redis批量原子扣减库存成功, count: {}", skuCodes.size());
        } else {
            log.warn("Redis批量原子扣减库存失败, count: {}", skuCodes.size());
        }
        
        return success;
    }
}
```

### 3.3 优惠券使用锁

#### 3.3.1 用户优惠券锁
```java
@Service
public class CouponLockService {
    
    @Autowired
    private RedisLock redisLock;
    
    /**
     * 锁定用户优惠券
     */
    public boolean lockUserCoupon(String userId, String couponId, String orderId) {
        String lockKey = RedisLockKeyConstants.COUPON_LOCK_KEY + userId + ":" + couponId;
        
        // 获取优惠券锁，超时时间30秒
        boolean locked = redisLock.lock(lockKey, 30);
        if (!locked) {
            log.error("获取优惠券锁失败, userId: {}, couponId: {}, orderId: {}", 
                     userId, couponId, orderId);
            throw new OrderBizException(OrderErrorCodeEnum.COUPON_LOCK_FAILED);
        }
        
        try {
            // 检查优惠券状态
            UserCouponDO userCoupon = userCouponDAO.getByCouponIdAndUserId(couponId, userId);
            if (userCoupon == null) {
                log.warn("优惠券不存在, userId: {}, couponId: {}", userId, couponId);
                return false;
            }
            
            if (!CouponStatusEnum.AVAILABLE.getCode().equals(userCoupon.getStatus())) {
                log.warn("优惠券不可用, userId: {}, couponId: {}, status: {}", 
                        userId, couponId, userCoupon.getStatus());
                return false;
            }
            
            if (userCoupon.getExpireTime().before(new Date())) {
                log.warn("优惠券已过期, userId: {}, couponId: {}, expireTime: {}", 
                        userId, couponId, userCoupon.getExpireTime());
                return false;
            }
            
            // 锁定优惠券
            boolean lockSuccess = doLockCoupon(userId, couponId, orderId);
            if (lockSuccess) {
                log.info("优惠券锁定成功, userId: {}, couponId: {}, orderId: {}", 
                        userId, couponId, orderId);
                
                // 记录优惠券操作日志
                recordCouponOperation(userId, couponId, orderId, CouponOperationTypeEnum.LOCK);
            }
            
            return lockSuccess;
            
        } finally {
            redisLock.unlock(lockKey);
        }
    }
    
    /**
     * 释放用户优惠券锁
     */
    public boolean releaseUserCoupon(String userId, String couponId, String orderId) {
        String lockKey = RedisLockKeyConstants.COUPON_RELEASE_KEY + userId + ":" + couponId;
        
        boolean locked = redisLock.lock(lockKey, 10);
        if (!locked) {
            log.error("获取优惠券释放锁失败, userId: {}, couponId: {}, orderId: {}", 
                     userId, couponId, orderId);
            return false;
        }
        
        try {
            boolean releaseSuccess = doReleaseCoupon(userId, couponId, orderId);
            if (releaseSuccess) {
                log.info("优惠券释放成功, userId: {}, couponId: {}, orderId: {}", 
                        userId, couponId, orderId);
                
                // 记录优惠券操作日志
                recordCouponOperation(userId, couponId, orderId, CouponOperationTypeEnum.RELEASE);
            }
            
            return releaseSuccess;
            
        } finally {
            redisLock.unlock(lockKey);
        }
    }
    
    private boolean doLockCoupon(String userId, String couponId, String orderId) {
        int updatedRows = userCouponDAO.lockCoupon(userId, couponId, orderId, CouponStatusEnum.LOCKED.getCode());
        return updatedRows > 0;
    }
    
    private boolean doReleaseCoupon(String userId, String couponId, String orderId) {
        int updatedRows = userCouponDAO.releaseCoupon(userId, couponId, orderId, CouponStatusEnum.AVAILABLE.getCode());
        return updatedRows > 0;
    }
    
    private void recordCouponOperation(String userId, String couponId, String orderId, CouponOperationTypeEnum operationType) {
        CouponOperationLogDO operationLog = new CouponOperationLogDO();
        operationLog.setUserId(userId);
        operationLog.setCouponId(couponId);
        operationLog.setOrderId(orderId);
        operationLog.setOperationType(operationType.getCode());
        operationLog.setOperationTime(new Date());
        couponOperationLogDAO.save(operationLog);
    }
}
```

## 4. 锁的监控与运维

### 4.1 锁监控指标

#### 4.1.1 锁性能监控
```java
@Component
public class LockMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    private final Counter lockAcquireCounter;
    private final Timer lockHoldTimer;
    private final Gauge activeLockGauge;
    
    public LockMetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        this.lockAcquireCounter = Counter.builder("redis.lock.acquire")
            .description("Redis锁获取次数")
            .register(meterRegistry);
            
        this.lockHoldTimer = Timer.builder("redis.lock.hold.duration")
            .description("Redis锁持有时间")
            .register(meterRegistry);
            
        this.activeLockGauge = Gauge.builder("redis.lock.active.count")
            .description("当前活跃锁数量")
            .register(meterRegistry, this, LockMetricsCollector::getActiveLockCount);
    }
    
    public void recordLockAcquire(String lockKey, boolean success) {
        lockAcquireCounter.increment(
            Tags.of("key", lockKey, "result", success ? "success" : "failure")
        );
    }
    
    public void recordLockHold(String lockKey, Duration duration) {
        lockHoldTimer.record(duration, Tags.of("key", lockKey));
    }
    
    private double getActiveLockCount() {
        // 获取当前活跃锁数量的逻辑
        return RedisLockManager.getActiveLockCount();
    }
}
```

#### 4.1.2 锁超时监控
```java
@Component
public class LockTimeoutMonitor {
    
    @Scheduled(fixedRate = 60000) // 每分钟检查一次
    public void checkLockTimeout() {
        Map<String, LockInfo> activeLocks = RedisLockManager.getActiveLocks();
        
        long currentTime = System.currentTimeMillis();
        List<String> timeoutLocks = new ArrayList<>();
        
        for (Map.Entry<String, LockInfo> entry : activeLocks.entrySet()) {
            String lockKey = entry.getKey();
            LockInfo lockInfo = entry.getValue();
            
            long holdTime = currentTime - lockInfo.getAcquireTime();
            if (holdTime > lockInfo.getTimeoutThreshold()) {
                timeoutLocks.add(lockKey);
                
                log.warn("发现超时锁, key: {}, holdTime: {}ms, threshold: {}ms", 
                        lockKey, holdTime, lockInfo.getTimeoutThreshold());
            }
        }
        
        if (!timeoutLocks.isEmpty()) {
            // 发送超时告警
            sendLockTimeoutAlert(timeoutLocks);
        }
    }
    
    private void sendLockTimeoutAlert(List<String> timeoutLocks) {
        LockTimeoutAlert alert = new LockTimeoutAlert();
        alert.setTimeoutLocks(timeoutLocks);
        alert.setAlertTime(new Date());
        alert.setMessage("发现" + timeoutLocks.size() + "个超时锁");
        
        alertService.sendAlert(alert);
    }
}
```

### 4.2 锁管理接口

#### 4.2.1 锁状态查询
```java
@RestController
@RequestMapping("/lock")
public class LockManagementController {
    
    @Autowired
    private RedisLock redisLock;
    
    @GetMapping("/active")
    public JsonResult<List<LockInfo>> getActiveLocks() {
        try {
            List<LockInfo> activeLocks = RedisLockManager.getActiveLocks();
            return JsonResult.buildSuccess(activeLocks);
        } catch (Exception e) {
            return JsonResult.buildError("QUERY_FAILED", e.getMessage());
        }
    }
    
    @GetMapping("/info/{lockKey}")
    public JsonResult<LockInfo> getLockInfo(@PathVariable String lockKey) {
        try {
            LockInfo lockInfo = RedisLockManager.getLockInfo(lockKey);
            if (lockInfo != null) {
                return JsonResult.buildSuccess(lockInfo);
            } else {
                return JsonResult.buildError("LOCK_NOT_FOUND", "锁不存在");
            }
        } catch (Exception e) {
            return JsonResult.buildError("QUERY_FAILED", e.getMessage());
        }
    }
    
    @PostMapping("/force-unlock/{lockKey}")
    public JsonResult<Boolean> forceUnlock(@PathVariable String lockKey) {
        try {
            boolean success = RedisLockManager.forceUnlock(lockKey);
            if (success) {
                log.warn("强制释放锁成功, lockKey: {}", lockKey);
                return JsonResult.buildSuccess(true);
            } else {
                return JsonResult.buildError("UNLOCK_FAILED", "强制释放锁失败");
            }
        } catch (Exception e) {
            log.error("强制释放锁异常, lockKey: {}", lockKey, e);
            return JsonResult.buildError("UNLOCK_ERROR", e.getMessage());
        }
    }
}
```

#### 4.2.2 锁统计信息
```java
@Service
public class LockStatisticsService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public LockStatistics getLockStatistics() {
        LockStatistics statistics = new LockStatistics();
        
        // 获取所有锁的key
        Set<String> lockKeys = redisTemplate.keys("lock:*");
        statistics.setTotalLockCount(lockKeys.size());
        
        // 按类型分组统计
        Map<String, Integer> lockTypeCount = new HashMap<>();
        for (String lockKey : lockKeys) {
            String lockType = extractLockType(lockKey);
            lockTypeCount.merge(lockType, 1, Integer::sum);
        }
        statistics.setLockTypeCount(lockTypeCount);
        
        // 获取锁持有时间统计
        Map<String, Long> lockHoldTimes = new HashMap<>();
        for (String lockKey : lockKeys) {
            Long ttl = redisTemplate.getExpire(lockKey);
            if (ttl != null && ttl > 0) {
                lockHoldTimes.put(lockKey, ttl);
            }
        }
        statistics.setLockHoldTimes(lockHoldTimes);
        
        return statistics;
    }
    
    private String extractLockType(String lockKey) {
        String[] parts = lockKey.split(":");
        if (parts.length >= 3) {
            return parts[1] + ":" + parts[2];
        }
        return "unknown";
    }
}
```

## 5. 最佳实践与注意事项

### 5.1 锁设计原则

1. **锁粒度控制**：选择合适的锁粒度，避免锁竞争过于激烈
2. **锁超时设置**：设置合理的锁超时时间，防止死锁
3. **锁顺序一致**：多个锁的获取顺序要一致，避免死锁
4. **异常处理**：确保在异常情况下能正确释放锁
5. **性能监控**：监控锁的获取成功率和持有时间

### 5.2 常见问题处理

#### 5.2.1 死锁检测与处理
```java
@Component
public class DeadlockDetector {
    
    @Scheduled(fixedRate = 300000) // 每5分钟检查一次
    public void detectDeadlock() {
        Map<String, LockInfo> activeLocks = RedisLockManager.getActiveLocks();
        
        // 构建锁依赖图
        Map<String, Set<String>> dependencyGraph = buildDependencyGraph(activeLocks);
        
        // 检测环形依赖
        List<List<String>> cycles = detectCycles(dependencyGraph);
        
        if (!cycles.isEmpty()) {
            log.error("检测到死锁, cycles: {}", cycles);
            
            // 发送死锁告警
            sendDeadlockAlert(cycles);
            
            // 尝试自动解决死锁
            resolveDeadlock(cycles);
        }
    }
    
    private void resolveDeadlock(List<List<String>> cycles) {
        for (List<String> cycle : cycles) {
            // 选择最老的锁进行强制释放
            String oldestLock = findOldestLock(cycle);
            if (oldestLock != null) {
                log.warn("强制释放死锁中的锁, lockKey: {}", oldestLock);
                RedisLockManager.forceUnlock(oldestLock);
            }
        }
    }
}
```

#### 5.2.2 锁泄漏检测
```java
@Component
public class LockLeakDetector {
    
    @Scheduled(fixedRate = 600000) // 每10分钟检查一次
    public void detectLockLeak() {
        Set<String> lockKeys = redisTemplate.keys("lock:*");
        
        List<String> leakedLocks = new ArrayList<>();
        long currentTime = System.currentTimeMillis();
        
        for (String lockKey : lockKeys) {
            // 检查锁是否长时间未释放
            Long ttl = redisTemplate.getExpire(lockKey);
            if (ttl == null || ttl == -1) { // 永不过期的锁
                leakedLocks.add(lockKey);
            } else {
                // 检查锁持有时间是否过长
                LockInfo lockInfo = RedisLockManager.getLockInfo(lockKey);
                if (lockInfo != null) {
                    long holdTime = currentTime - lockInfo.getAcquireTime();
                    if (holdTime > 3600000) { // 超过1小时
                        leakedLocks.add(lockKey);
                    }
                }
            }
        }
        
        if (!leakedLocks.isEmpty()) {
            log.warn("检测到可能的锁泄漏, count: {}, locks: {}", leakedLocks.size(), leakedLocks);
            
            // 发送锁泄漏告警
            sendLockLeakAlert(leakedLocks);
            
            // 可以考虑自动清理一些明显泄漏的锁
            cleanupLeakedLocks(leakedLocks);
        }
    }
}
```

### 5.3 性能优化建议

1. **使用Lua脚本**：对于复杂的原子操作，使用Lua脚本保证原子性
2. **锁池化管理**：对于频繁使用的锁，考虑使用对象池
3. **异步释放**：非关键路径的锁释放可以异步执行
4. **批量操作**：支持批量获取和释放锁
5. **监控优化**：基于监控数据持续优化锁的使用

## 总结

如意订单系统的分布式锁实现具有以下特点：

**技术优势**：
1. **基于Redisson**：功能丰富，支持重入锁、多重锁等
2. **高性能**：基于Redis集群，支持高并发
3. **可靠性**：完善的超时机制和异常处理
4. **可监控**：丰富的监控指标和管理接口

**应用场景**：
1. **订单支付**：防止重复支付和并发冲突
2. **库存管理**：防止库存超卖
3. **优惠券**：防止重复使用
4. **状态更新**：防止状态并发修改

**最佳实践**：
1. **合理设计锁粒度**：平衡性能和一致性
2. **完善异常处理**：确保锁能正确释放
3. **监控告警**：及时发现锁相关问题
4. **性能优化**：持续优化锁的使用效率

通过合理的分布式锁设计，系统能够在高并发环境下保证数据的一致性和业务的正确性。
